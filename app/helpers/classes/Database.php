<?php

	class Database {

		public static $__QUERIES__    = array( );
		public static $__TABLE__      = array( );
		public static $__CONNECTION__ = false;

		public function __construct ( $data = array( ) ) {
	        if ( is_array( $data ) ) {
	            $this->setFromData( $data );
	        }
	    }

	    public function setFromData ( $data ) {
	        foreach ( $data as $key => $value ) {
	            $this->$key = $value;
	        }
	    }

	    /**
	     * Sets a static reference for the connection to the database.
	     *
	     * @param <type> $connection
	     */
	    final public static function connection ( $connection ) {
	        self::$__CONNECTION__ = $connection;
	    }

	    /**
	     * Returns a reference to a database connection.
	     *
	     * @return <type>
	     */
	    final public static function getConnection ( ) {
	        return self::$__CONNECTION__;
	    }

	    /**
	     * Logs an SQL query.
	     *
	     * @param string $sql SQL query string.
	     */
	    final public static function logQuery ( $sql ) {
	        self::$__QUERIES__[] = $sql;
	    }

	    /**
	     * Retrieves all logged queries.
	     *
	     * @return array An array of queries.
	     */
	    final public static function getQueryLog ( $echo = true ) {
	        if ( $echo === true ) {
	        	foreach (self::$__QUERIES__ as $query ) {
					echo "<pre style='color: #ff0000;'>{$query}</pre>";
				}
	        } else {
	        	return self::$__QUERIES__;
	        }
	    }

	    /**
	     * Returns the number of logged queries.
	     *
	     * @return int Number of logged queries.
	     */
	    final public static function getQueryCount ( ) {
	        return count( self::$__QUERIES__ );
	    }

	    final public static function tableNameFromClassName ( $class_name ) {
	    	global $__DB_CONFIG__;

	    	$table_name = "{$class_name}::TABLE_NAME";

	        try {
	            if ( class_exists( $class_name ) && defined( $table_name ) ) {
	                return $__DB_CONFIG__['table_prefix'] . constant( $table_name );
	            }
	        } catch ( Exception $e ) {
	            return $__DB_CONFIG__['table_prefix'] . Inflector::underscore( $class_name );
	        }
	    }

	    /**
	     * Escapes quotes in a query string.
	     *
	     * @param string $value The query string to escape.
	     * @return string       The escaped string.
	     */
	    final public static function escape ( $value ) {
	        return self::$__CONNECTION__->quote( $value );
	    }

	    /**
	     * Retrieves the autogenerated primary key for the last inserted record.
	     *
	     * @return string A key.
	     */
	    final public static function lastInsertId ( ) {
	        return self::$__CONNECTION__->lastInsertId( );
	    }

	    /**
	     * Executes an SQL query.
	     *
	     * @param string $sql   SQL query to execute.
	     * @param array $values Values belonging to the SQL query if its a prepared statement.
	     * @return <type>       An array of objects, PDOStatement object or FALSE on failure.
	     */
	    final public static function sqlQuery( $sql, $values = false ) {
	        self::logQuery( $sql );

	        if ( is_array( $values ) && !empty( $values ) ) {
	            $stmt = self::$__CONNECTION__->prepare( $sql );
	            $stmt->execute( $values );

	            return $stmt->fetchAll( self::FETCH_OBJ );
	        } else {
	            return self::$__CONNECTION__->query( $sql );
	        }
	    }

	   	public static function sqlSelect ( $args = array( ), $binds = array( ) ) {
			$data   = array( );
			$table  = array_key_exists( 'table', $args ) ? $args['table'] : false;
			$column = array_key_exists( 'column', $args ) ? $args['column'] : false;
			$where  = array_key_exists( 'where', $args ) ? $args['where'] : false;
			$group  = array_key_exists( 'group', $args ) ? $args['group'] : false;
			$having = array_key_exists( 'having', $args ) ? $args['having'] : false;
			$order  = array_key_exists( 'order', $args ) ? $args['order'] : false;
			$limit  = array_key_exists( 'limit', $args ) ? $args['limit'] : false;
			$offset = array_key_exists( 'offset', $args ) ? $args['offset'] : false;

			$sql_values = array_merge( array_key_exists( 'binds', $args ) ? $args['binds'] : array( ), $binds );
			$sql_params = array(
				'table'  => ( $table ) ? $table : '',
				'column' => ( $column ) ? $column : '*',
				'where'  => ( $where ) ? 'WHERE ' . $where : '',
				'group'  => ( $group ) ? 'GROUP BY ' . $group : '',
				'having' => ( $having ) ? 'HAVING ' . $having : '',
				'order'  => ( $order ) ? 'ORDER BY ' . $order : '',
				'limit'  => ( $limit ) ? 'LIMIT ' . (int) $limit : '',
				'offset' => ( $offset ) ? 'OFFSET ' . (int) $offset : ''
			);

			$sql_statement = "SELECT {$sql_params['column']} FROM {$sql_params['table']} {$sql_params['where']} {$sql_params['group']} {$sql_params['having']} {$sql_params['order']} {$sql_params['limit']} {$sql_params['offset']};";

			self::logQuery( $sql_statement );

			$stmt = self::$__CONNECTION__->prepare( $sql_statement );
			$stmt->execute( $sql_values );

			if ( $limit == 1 ) {
				$data = $stmt->fetchObject( get_called_class( ) );
			} else {
				while (  $sql_row = $stmt->fetchObject( get_called_class( ) ) ) {
					$data[] = $sql_row;
				}
			}

			return $data;
		}

		public static function sqlInsert ( $data = array( ), $table = false ) {
			$data            = ( is_array( $data ) ) ? $data : array( );
			$sql_keys        = array( );
			$sql_values      = array( );
			$sql_values_keys = array( );

			foreach ( $data as $key => $value  ) {
				$sql_keys[] = $key;

				if ( is_array( $value ) ) {
					if ( $value['quote'] == false ) {
						$sql_values_keys['NOW( )'] = false;
					} else {
						$sql_values_keys[":{$key}"] = $value;
						$sql_values[":{$key}"] = $value;
					}
				} else {
					$sql_values_keys[":{$key}"] = $value;
					$sql_values[":{$key}"] = $value;
				}
			}

			$sql_statement = "INSERT INTO `{$table}` (" . join( ", ", $sql_keys ). ") VALUES (" . join( ", ", array_keys( $sql_values_keys ) ) . ");";

			self::logQuery( $sql_statement );

			$stmt = self::$__CONNECTION__->prepare( $sql_statement );

            return $stmt->execute( $sql_values ) !== false;
		}

		public static function sqlUpdate ( $data = array( ), $where = '', $table = false ) {
			$data       = ( is_array( $data ) ) ? $data : array( );
			$sql_keys   = array( );
			$sql_values = array( );

			foreach ( $data as $key => $value  ) {
				if ( is_array( $value ) ) {
					$sql_keys[] = "{$key} " . ( isset( $value['operand'] ) ? $value['operand'] : '=' ) . " " . ( isset( $value['quote'] ) ? $value['quote'] : "'" ) . $value[0] . ( isset( $value['quote'] ) ? $value['quote'] : "'" );
				} else {
					$sql_keys[] = "{$key} = :{$key}";
					$sql_values[":{$key}"] = $value;
				}
			}

			$sql_statement = "UPDATE {$table} SET " . join( ", ", $sql_keys ). " WHERE {$where};";

			self::logQuery( $sql_statement );

			$stmt = self::$__CONNECTION__->prepare( $sql_statement );

            return $stmt->execute( $sql_values ) !== false;
		}

		public static function sqlDelete ( $args = array( ), $binds = array( ) ) {
			$table  = array_key_exists( 'table', $args ) ? $args['table'] : false;
			$where  = array_key_exists( 'where', $args ) ? $args['where'] : false;
			$order  = array_key_exists( 'order', $args ) ? $args['order'] : false;
			$limit  = array_key_exists( 'limit', $args ) ? $args['limit'] : false;
			$offset = array_key_exists( 'offset', $args ) ? $args['offset'] : false;

			$sql_values = array_merge( array_key_exists( 'binds', $args ) ? $args['binds'] : array( ), $binds );
			$sql_params = array(
				'table'  => ( $table ) ? $table : '',
				'where'  => ( $where ) ? 'WHERE ' . $where : '',
				'order'  => ( $order ) ? 'ORDER BY ' . $order : '',
				'limit'  => ( $limit ) ? 'LIMIT ' . ( int ) $limit : '',
				'offset' => ( $offset ) ? 'OFFSET ' . ( int ) $offset : ''
			);

			$sql_statement = "DELETE FROM {$sql_params['table']} {$sql_params['where']} {$sql_params['order']} {$sql_params['limit']} {$sql_params['offset']};";

			self::logQuery( $sql_statement );

			$stmt = self::$__CONNECTION__->prepare( $sql_statement );

            return $stmt->execute( $sql_values ) !== false;
		}

		// --------------------------------------------------------------------------------------------------------
		// 		SQL FUNCTIONS
		// --------------------------------------------------------------------------------------------------------

		public function getColumns ( $table ) {
			if ( in_array( $table, self::$__TABLE__ ) ) {
			 	$columns = self::$__TABLE__[$table];
			} else {
				$sql_statement = "DESCRIBE {$table};";

				self::logQuery( $sql_statement );

				$stmt = self::$__CONNECTION__->prepare( $sql_statement );

				$stmt->execute( $sql_values );

				$columns = $stmt->fetchAll( PDO::FETCH_COLUMN );

				if ( !empty( $columns ) ) {
					self::$__TABLE__[$table] = $columns;
				}
			}

			return $columns;
	    }

	    public function beforeSave ( ) { return true; }

	    public function beforeInsert ( ) { return true; }

	    public function beforeUpdate ( ) { return true; }

	    public function beforeDelete ( ) { return true; }

	    public function afterSave ( ) { return true; }

	    public function afterInsert ( ) { return true; }

	    public function afterUpdate ( ) { return true; }

	    public function afterDelete ( ) { return true; }

		public static function findAll ( $parameters = array( ), $binds = array( ), $table = '' ) {
			$table = ( !$table ) ? self::tableNameFromClassName( get_called_class( ) ) : $table;

			if ( !is_array( $parameters ) ) {
				$parameters = array( 'where' => $parameters );
			}

			return self::sqlSelect( array_merge( array( 'table' => $table ), $parameters ), $binds );
		}

		public static function findBy ( $parameters = array( ), $binds = array( ), $limit = 1, $table = '' ) {
			if ( !is_array( $parameters ) ) {
				$parameters = array( 'where' => $parameters );
			}

			return self::findAll( array_merge( array( 'limit' => $limit ), $parameters ), $binds, $table );
		}

		public static function findById ( $primary_value, $primary_key = 'id', $limit = 1, $table = '' ) {
			return self::findBy( array(
				'where' => "{$primary_key} = :id",
			), array(
				'id' => $primary_value
			), $limit, $table );
		}

		public static function count ( $parameters = array( ), $binds = array( ), $table = '' ) {
			$table = ( !$table ) ? self::tableNameFromClassName( get_called_class( ) ) : $table;

			if ( !is_array( $parameters ) ) {
				$parameters = array( 'where' => $parameters );
			}

			$data = self::sqlSelect( array_merge( array( 'table' => $table, 'column' => 'COUNT(*) AS cnt' ), $parameters ), $binds );

			return (int) $data[0]->cnt;
		}

		public static function delete ( $parameters = array( ), $binds = array( ), $table = '' ) {
			$table = ( !$table ) ? self::tableNameFromClassName( get_called_class( ) ) : $table;

			if ( !is_array( $parameters ) ) {
				$parameters = array( 'where' => $parameters );
			}

			return self::sqlDelete( array_merge( array( 'table' => $table ), $parameters ), $binds );
		}

		public function erase ( $primary_key = 'id' ) {
			if ( !$this->beforeDelete( ) ) return false;

			$return = self::delete( "{$primary_key} = :id", array(
				'id' => $this->{$primary_key}
			));

			if ( !$this->afterDelete( ) ) return false;

			return $return;
		}

		public function save ( $primary_key = 'id' ) {
			$data   = array( );
			$table  = self::tableNameFromClassName( get_called_class( ) );
			$return = false;

			if ( !$this->beforeSave( ) ) return false;

			$columns = $this->getColumns( $table );
			$action  = 'add';

			if ( isset( $this->$primary_key ) ) {
				if ( !empty( $this->$primary_key ) && $this->$primary_key ) {
					$action = 'edit';
				}
			}

			if  ( $action == 'add' ) {
				if ( !$this->beforeInsert( ) ) return false;

				foreach ( $columns as $column ) {
	                if ( !empty( $this->$column ) || is_numeric( $this->$column ) ) {
	                    $data[$column] = $this->$column;
	                } else if ( isset( $this->$column ) ) {
	                    if ( self::getConnection( )->getAttribute( \PDO::ATTR_DRIVER_NAME ) != 'sqlite' ) {
	                        $data[$column] = NULL;
	                    }
	                }
	            }

				$return   = self::sqlInsert( $data, $table );
				$this->id = self::lastInsertId( );

				if ( !$this->afterInsert( ) ) return false;

			} else if ( $action == 'edit' ) {
				if ( !$this->beforeUpdate( ) ) return false;

				foreach ( $columns as $column ) {
	                if ( !empty( $this->$column ) || is_numeric( $this->$column ) ) {
	                    $data[$column] = $this->$column;
	                } else if ( isset( $this->$column ) ) {
	                    if ( self::getConnection( )->getAttribute( \PDO::ATTR_DRIVER_NAME ) != 'sqlite' ) {
	                        $data[$column] = NULL;
	                    }
	                }
	            }

				$primary_value = self::escape( $data[$primary_key] );
				unset( $data[$primary_key] );
				$return = self::sqlUpdate( $data, "{$primary_key} = {$primary_value}", $table );

				if ( !$this->afterUpdate( ) ) return false;
			}

			if ( !$this->afterSave( ) ) return false;

			return $return;
		}

		public function resave ( $primary_key = 'id' ) {
	        if ( !$this->beforeDelete( ) ) return false;

	        $return = $this->delete( "{$primary_key} = ?", array( $this->$primary_key ) );

	        if ( !$this->afterDelete( ) ) {
	        	$this->save( );
	        	return false;
	        }

	        if ( $return ) {
	        	unset( $this->id );
	        	$this->save( );
	        }

	        return $return;

	    }
	}